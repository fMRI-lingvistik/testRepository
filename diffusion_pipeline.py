import os from os.path import abspathfrom datetime import datetimefrom IPython.display import Imageimport pydotfrom nipype import Workflow, Node, MapNode, Function, configfrom nipype.interfaces.fsl import TOPUP, ApplyTOPUP, BET, ExtractROI,  Eddy, FLIRT, FUGUEfrom nipype.interfaces.fsl.maths import MathsCommandimport nipype.interfaces.utility as util import nipype.interfaces.mrtrix3 as mrt#Requirements for the workflow to run smoothly: All files as in NIfTI-format and named according to the following standard: #Images are from the tonotopy DKI sequences on the 7T Philips Achieva scanner in Lund. It should work with any DKI sequence and possibly also a standard DTI but the setting for B0-corrections, epi-distortion corrections and eddy current corrections will be wrong. #DKI file has a base name shared with bvec and bval in FSL format. E.g. "DKI.nii.gz" "DKI.bvec" and "DKI.bval". #There is one b0-volume with reversed (P->A) phase encoding called DKIbase+_revenc. E.g. "DKI_revenc.nii.gz". #Philips B0-map magnitude and phase offset (in Hz) images. #One input file for topup describing the images as specified by topup. #Set nbrOfThreads to number of available CPU threads to run the analyses. ### Need to make better revenc for the 15 version if we choose to use it (i.e. same TE and TR)#Set to relevant directory/parametersdatadir=os.path.abspath("/Users/ling-men/Documents/MRData/testDKI")rawDKI_base='DKI_15' B0map_base = 'B0map'nbrOfThreads=6print_graph = True acqparam_file = os.path.join(datadir,'acqparams.txt')index_file = os.path.join(datadir,'index.txt')#####config.enable_debug_mode()DKI_nii=os.path.join(datadir, rawDKI_base+'.nii.gz')DKI_bval=os.path.join(datadir, rawDKI_base+'.bval')DKI_bvec=os.path.join(datadir, rawDKI_base+'.bvec')DKI_revenc=os.path.join(datadir, rawDKI_base+'_revenc.nii.gz')B0map_mag = os.path.join(datadir,B0map_base+'_mag.nii.gz')B0map_phase = os.path.join(datadir,B0map_base+'_phase.nii.gz')#Load relevant files.os.chdir(datadir)### Here, one should check the inputs. #Convert to mif for the first time. N.B! Need newest version from dev for the number of shells to be allright.### Maybe check number of shells.mrconvert_mif = Node(mrt.MRConvert(in_file=DKI_nii, grad_fsl=(DKI_bvec, DKI_bval), out_file=os.path.join(datadir, rawDKI_base+'.mif')), name="mrconvert_mif")#DWI denoise. Doesn't do amazing difference but some at least. dwidenoise = Node(mrt.DWIDenoise(nthreads=nbrOfThreads), name="dwidenoise")#Convert denoised back to NIfTImrconvert_nii = Node(mrt.MRConvert(out_file=os.path.join(datadir, rawDKI_base+'_denoised.nii')), name='mrconvert_nii')#Run topup to reduce epi-readout artefactsfslroi = Node(ExtractROI(roi_file=os.path.join(datadir, rawDKI_base+'_dn_nodif.nii.gz'), t_min=0, t_size=1), name="fslroi")                #Write a specific TonMergedef TonMerge(nodiff_file):    from nipype.interfaces.fsl import Merge    basename = nodiff_file.replace('_dn_nodif.nii.gz','')    revencfile = nodiff_file.replace('_dn_nodif.nii.gz','_revenc.nii.gz')    fslmerge = Merge(in_files=[revencfile, nodiff_file],dimension='t',merged_file=basename+'_encfix.nii.gz')    merged_file = fslmerge.run()    return merged_file.outputs.merged_fileTonMerge_node = Node(Function(input_names=["nodiff_file"], output_names=["merged_file"], function=TonMerge), name="TonMerge_node")# tpup = TOPUP() # --config=b02b0.cnf is deafult.# tpup.inputs.in_file = 'DKI_encfix.nii.gz'# tpup.inputs.encoding_file = 'acqparams.txt' #acqparams.txt is in the data folder# tpup.inputs.out_base = 'DKI_topup_param'# tpup.run()topupnode = Node(TOPUP(encoding_file=acqparam_file, out_base=os.path.join(datadir,rawDKI_base+'_topup_param')), name = "topupnode")# atpup = ApplyTOPUP()# atpup.inputs.in_files = 'DKI_denoised.nii'# atpup.inputs.encoding_file = 'acqparams.txt'# atpup.inputs.in_index = [2]# atpup.inputs.in_topup_fieldcoef = 'DKI_topup_param_fieldcoef.nii.gz'# atpup.inputs.in_topup_movpar = 'DKI_topup_param_movpar.txt'# atpup.inputs.method = 'jac'# atpup.inputs.out_corrected = 'DKI_dn_topuped'# atpup.run()applytopupnode = Node(ApplyTOPUP(encoding_file=acqparam_file, in_index=[2], method='jac', out_corrected=os.path.join(datadir, rawDKI_base+'_dn_topuped.nii.gz')), name="applytopupnode")#Use fieldmap to reduce B0 inhomogeneities#   Scanner gives mag and (wrapped) phase images in frequency offset (Hz)# Dwell time is the same as echo spacing. echo spacing in msec = 1000 * (water-fat shift (per pixel)/(water-fat shift (in Hz) * echo train length))### B0 map: Need asymtime (echo time difference) 1 ms. ### DKI sequence: Need Dwell time # WFS (pixel) = 54.382# water-fat-shift (Hz) = fieldstrength (T) * water-fat difference (ppm) * resonance frequency (MHz/T)# Water fat difference = 3.35 ppm# Resonance frequency = 42.576 MHz/T# echo train length (etl) = EPI factor + 1 # EPI factor = 89# Dwell time for DKI sequence = 0.6052084204164838 ms# SENSE = 1.5# Dwell time to use = 0.6052084204164838/1.5 = 0.40347228027765586 but must be in seconds.# Dwell time in s = 0.00040347228027765584# Phase image must be in rad/s. Scale by multiplying with 6.28. # Register the fieldmap to the EPI. # flirt -in B0map_brain.nii.gz -ref DKI_dn_nodif.nii.gz -out B0map_brain_DKI -omat B02DKI.mat# flirt -in B0map_phase_rads_brain.nii.gz -ref DKI_dn_nodif.nii.gz -applyxfm -init B02DKI.mat -out B0map_phase_rads_DKI# flirt -in B0map_brain_mask.nii.gz -ref DKI_dn_nodif.nii.gz -applyxfm -init B02DKI.mat -out B0map_brain_maks_DKI# fslmaths B0map_brain_mask_DKI.nii.gz -bin B0map_brain_mask_DKI# fugue -i DKI_denoised.nii --loadfmap=B0map_phase_rads_DKI.nii.gz --dwell=0.00040347228027765584 --mask=B0map_brain_mask_DKI.nii.gz -u DKI_dn_B0corrB0hz2rads = Node(MathsCommand(in_file=B0map_phase, args = "-mul 6.28", out_file=os.path.join(datadir,B0map_base+'_phase_rads.nii.gz')),name="B0hz2rads")B0_BET = Node(BET(in_file=B0map_mag, mask=True, out_file=os.path.join(datadir,B0map_base+'_brain.nii.gz')), name="B0_BET")B0_binmask = Node(MathsCommand(args = "-bin", out_file = os.path.join(datadir,B0map_base+'_brain_mask.nii.gz')), name = "B0_binmask")B0brain2DKI_flirt = Node(FLIRT(out_matrix_file=os.path.join(datadir,'B02DKI.mat'), out_file=os.path.join(datadir,B0map_base+'_brain_DKI.nii.gz')), name="B0brain2DKI_flirt")B0phaseBrain = Node(MathsCommand(args = '-mul '+os.path.join(datadir,B0map_base+'_brain_mask.nii.gz'), out_file=os.path.join(datadir,B0map_base+'_phase_rads_brain.nii.gz')),name="B0phaseBrain")B0phase2DKI_flirt = Node(FLIRT(apply_xfm=True, out_file=os.path.join(datadir,B0map_base+'_phase_rads_DKI.nii.gz')), name="B0phase2DKI_flirt")B0mask2DKI_flirt = Node(FLIRT(apply_xfm=True, out_file=os.path.join(datadir,B0map_base+'_brain_mask_DKI.nii.gz')), name="B0mask2DKI_flirt")BinarizeB0mask = Node(MathsCommand(args = '-bin', out_file=os.path.join(datadir,B0map_base+'_brain_mask_DKI.nii.gz')),name="BinarizeB0mask")  B0correct = Node(FUGUE(dwell_time=0.00040347228027765584, unwarped_file=os.path.join(datadir, rawDKI_base+'_dn_B0corr.nii.gz')), name="B0correct") # #Get a good brain mask from b0, Maybe but for now trust the mag-brain. # fslroi = ExtractROI(in_file='DKI_dn_topuped.nii.gz', roi_file='DKI_dn_topuped_nodif.nii.gz', t_min=0, t_size=1)# fslroi.run() # bet = BET()# bet.inputs.in_file = 'DKI_dn_topuped_nodif.nii.gz'# bet.inputs.frac = 0.2# bet.inputs.mask = True# bet.inputs.out_file = 'DKI_dn_topuped_nodif_brain.nii.gz'# bet.run()fslroi_II = Node(ExtractROI(roi_file=os.path.join(datadir, rawDKI_base+'_dn_topuped_nodif.nii.gz'), t_min=0, t_size=1), name="fslroi_II")DK_bet = Node(BET(frac = 0.2, out_file = os.path.join(datadir, rawDKI_base+'_dn_topuped_nodif_brain.nii.gz')), name="DK_bet")DK_binmask = Node(MathsCommand(args = "-bin", out_file = os.path.join(datadir, rawDKI_base+'_dn_topuped_nodif_brain_mask.nii.gz')), name = "DK_binmask")# #Run eddy for eddy current and motion correction# #Index is the row in acqparam that describes the data, created before analysis# #Had to patch in the eddy_cpu from fsl website and replace the old "eddy" with eddy_cpu# #Still doesn't work without increasing b=100. Done on the scanner. # # eddy = Eddy()# # eddy.inputs.in_file = 'DKI_dn_topuped.nii.gz'# # eddy.inputs.in_mask = 'DKI_dn_topuped_nodif_brain_mask.nii.gz'# # eddy.inputs.in_acqp = 'acqparams.txt' # # eddy.inputs.in_index = 'index.txt'# # eddy.inputs.in_bval = 'DKI.bval'# # eddy.inputs.in_bvec = 'DKI.bvec'# # eddy.inputs.in_topup_fieldcoef = 'DKI_topup_param_fieldcoef.nii.gz'# # eddy.inputs.in_topup_movpar = 'DKI_topup_param_movpar.txt'# # eddy.inputs.is_shelled = True# # eddy.inputs.num_threads = 6 #Possibly make this a setting# # eddy.inputs.out_base = 'DKI_dn_topuped_eddy'# # now = datetime.now() #Turn this into small function# # current_time = now.strftime("%H:%M:%S")# # print("Current Time =", current_time)# # eddy.run()# # now = datetime.now() #Turn this into small function# # current_time = now.strftime("%H:%M:%S")# # print("Current Time =", current_time)eddy_correct = Node(Eddy(in_acqp = acqparam_file, in_index = index_file, in_bval = DKI_bval, in_bvec = DKI_bvec, is_shelled = True, num_threads = nbrOfThreads, out_base=os.path.join(datadir, rawDKI_base+'_dn_topuped_B0corr_eddy')), name="eddy_correct")# #Run tractography from MRTrix3# #Convert to mif# mrconvert = mrt.MRConvert()# mrconvert.inputs.in_file = 'DKI_dn_topuped_mc.nii.gz'# mrconvert.inputs.grad_fsl = ('DKI.bvec', 'DKI.bval')# mrconvert.inputs.out_file = 'DKI_dn_topuped_mc.mif'# mrconvert.run()mrconvert_DK = Node(mrt.MRConvert(grad_fsl = (DKI_bvec, DKI_bval), out_file = os.path.join(datadir, rawDKI_base+'_dn_topuped_B0corr_eddy.mif')),name = "mrconvert_DK")# #Mask# mrconvert = mrt.MRConvert()# mrconvert.inputs.in_file = 'DKI_dn_topuped_nodif_brain_mask.nii.gz'# mrconvert.inputs.out_file = 'DKI_mask.mif'# mrconvert.run()mrconvert_mask = Node(mrt.MRConvert(out_file = os.path.join(datadir, rawDKI_base+'_mask.mif')),name = "mrconvert_mask")                    # #dwi2response dhollander for possibility of FBA later# # For now DKI_dn_topuped_mc.nii.gz but change to whatever the output of eddy is called.# dtr = mrt.ResponseSD()# dtr.inputs.in_file = 'DKI_dn_topuped_mc.mif'# dtr.inputs.algorithm = 'dhollander'# dtr.inputs.grad_fsl = ('DKI.bvec', 'DKI.bval')# dtr.inputs.csf_file = 'DKI_csf.txt'# dtr.inputs.gm_file = 'DKI_gm.txt'# dtr.inputs.wm_file = 'DKI_wm.txt'# dtr.inputs.nthreads = 6 #Possibly turn into a setting# dtr.run()dwResponse = Node(mrt.ResponseSD(algorithm = 'dhollander', grad_fsl = (DKI_bvec, DKI_bval), nthreads = nbrOfThreads, csf_file = os.path.join(datadir, rawDKI_base+'_csf.txt'), gm_file = os.path.join(datadir, rawDKI_base+'_gm.txt'), wm_file = os.path.join(datadir, rawDKI_base+'_wm.txt')), name = "dwResponse")# #dwi2fod# fod = mrt.EstimateFOD()# fod.inputs.algorithm = 'msmt_csd' # fod.inputs.in_file = 'DKI_dn_topuped_mc.nii.gz'# fod.inputs.grad_fsl = ('DKI.bvec', 'DKI.bval')# fod.inputs.nthreads = 6 #Possibly turn into a setting# fod.inputs.wm_txt = 'DKI_wm.txt'# fod.inputs.wm_odf = 'DKI_wm_odf.mif'# fod.inputs.gm_txt = 'DKI_gm.txt'# fod.inputs.gm_odf = 'DKI_gm_odf.mif'# fod.inputs.csf_txt = 'DKI_csf.txt'# fod.inputs.csf_odf = 'DKI_csf_odf.mif'# fod.inputs.mask_file = 'DKI_mask.mif'# fod.inputs.max_sh = [8,8,8]; #Not extremely sure about this.# fod.run()dwFOD = Node(mrt.EstimateFOD(algorithm = 'msmt_csd', grad_fsl = (DKI_bvec, DKI_bval), max_sh = [8,8,8], nthreads = nbrOfThreads, csf_odf=os.path.join(datadir, rawDKI_base+'_csf_odf.mif'), gm_odf=os.path.join(datadir, rawDKI_base+'_gm_odf.mif'), wm_odf=os.path.join(datadir, rawDKI_base+'_wm_odf.mif')), name = "dwFOD")# #tckgen# #tckgen ${subj}_fod.mif ${subj}_tracks.tck -nthreads 6 -seed_image ${subj}_DTIbrainmask.nii.gz -mask ${subj}_DTIbrainmask.nii.gz -number 5000000# tk = mrt.Tractography()# tk.inputs.in_file = 'DKI_wm_odf.mif'# tk.inputs.nthreads = 6 #Possibly turn into a setting# tk.inputs.roi_mask = 'DKI_mask.mif'# tk.inputs.seed_image = 'DKI_mask.mif'# tk.inputs.select = 5000000 #Might have to be more.# tk.inputs.out_file = 'DKI_tracks.tck'# tk.run()tckgen = Node(mrt.Tractography(nthreads = nbrOfThreads, select = 5000000, out_file = os.path.join(datadir, rawDKI_base+'_tracks.tck')), name = "tckgen")wf_tonDKI = Workflow(name="Tonotopy_DKI_workflow", base_dir=datadir)wf_tonDKI.connect([(mrconvert_mif, dwidenoise, [("out_file", "in_file")]),                     (dwidenoise, mrconvert_nii, [("out_file", "in_file")]),                     (mrconvert_nii, fslroi, [("out_file", "in_file")]),                     (fslroi, TonMerge_node, [("roi_file", "nodiff_file")]),                     (TonMerge_node, topupnode, [("merged_file", "in_file")]),                     (topupnode, applytopupnode, [("out_fieldcoef","in_topup_fieldcoef"),                                                                                               ("out_movpar","in_topup_movpar")]),                     (mrconvert_nii, applytopupnode, [("out_file", "in_files")]),                     (B0hz2rads, B0phaseBrain, [("out_file", "in_file")]),                     (B0_BET, B0_binmask, [("out_file", "in_file")]),                     (B0_BET, B0brain2DKI_flirt, [("out_file","in_file")]),                     (fslroi, B0brain2DKI_flirt, [("roi_file", "reference")]),                     (fslroi, B0phase2DKI_flirt, [("roi_file", "reference")]),                     (B0brain2DKI_flirt, B0phase2DKI_flirt, [("out_matrix_file", "in_matrix_file")]),                     (B0phaseBrain, B0phase2DKI_flirt, [("out_file", "in_file")]),                     (fslroi, B0mask2DKI_flirt, [("roi_file", "reference")]),                     (B0brain2DKI_flirt, B0mask2DKI_flirt, [("out_matrix_file", "in_matrix_file")]),                     (B0_binmask, B0mask2DKI_flirt, [('out_file','in_file')]),                     (B0mask2DKI_flirt, BinarizeB0mask, [("out_file","in_file")]),                     (B0phase2DKI_flirt,B0correct, [("out_file", "fmap_in_file")]),                     (BinarizeB0mask,B0correct, [("out_file", "mask_file")]),                     (applytopupnode, B0correct, [("out_corrected", "in_file")]),                     #                     (B0correct, fslroi_II, [("unwarped_file", "in_file")]),                     (fslroi_II, DK_bet, [("roi_file", "in_file")]),                     (DK_bet, DK_binmask, [("out_file", "in_file")]),                     (B0correct, eddy_correct, [("unwarped_file", "in_file")]),                     (DK_binmask, eddy_correct, [("out_file", "in_mask")]),                     (topupnode, eddy_correct, [("out_fieldcoef","in_topup_fieldcoef"),                                                ("out_movpar","in_topup_movpar")]),#Might have to be changed.                     (eddy_correct, mrconvert_DK, [("out_corrected", "in_file")]),                     (DK_binmask, mrconvert_mask, [("out_file", "in_file")]),                     (mrconvert_DK, dwResponse, [("out_file", "in_file")]),                     (mrconvert_DK, dwFOD, [("out_file", "in_file")]),                     (mrconvert_mask, dwFOD, [("out_file", "mask_file")]),                     (dwResponse, dwFOD, [("csf_file", "csf_txt"),                                          ("gm_file", "gm_txt"),                                          ("wm_file", "wm_txt")]),                     (dwFOD, tckgen, [("wm_odf", "in_file")]),                     (mrconvert_mask, tckgen, [("out_file", "roi_mask"),                                               ("out_file", "seed_image")])                     ])#Test workflowwf_tonDKI.run()if print_graph:    wf_tonDKI.write_graph("wf_tonotopy_graph.dot")    Image(filename=os.path.join(datadir,'Tonotopy_DKI_workflow','wf_tonotopy_graph.png'))### STEPS TO ADD# Get Eddy to run with multiple threads.        # #Get DKI parameters from some software# https://dipy.org/documentation/1.0.0./examples_built/reconst_dki/# Fixel based analysis: https://mrtrix.readthedocs.io/en/0.3.16/workflows/fixel_based_analysis.html